import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
import { logger } from "../modules/logger/core/logger.js";
import {
	LOGIN_DELAY_MS,
	allowRequest,
	createRateLimitMiddleware,
	rateLimitLogin,
	resetLoginAttempts,
	startCleanupInterval,
} from "./rateLimit.js";

// Mock logger
vi.mock("../modules/logger/core/logger.js", () => ({
	logger: {
		debug: vi.fn(),
	},
}));

describe("rate limiting utilities", () => {
	beforeEach(() => {
		// Reset environment variables
		process.env.RATE_LIMIT_TOKENS = "60";
		process.env.RATE_LIMIT_INTERVAL_MS = "60000";
		process.env.LOGIN_RATE_LIMIT_MAX = "10";
		process.env.LOGIN_RATE_LIMIT_WINDOW_MS = "900000";
		vi.clearAllMocks();
		// Reset module state by re-importing
		vi.resetModules();
	});

	afterEach(() => {
		vi.useRealTimers();
	});

	describe("allowRequest", () => {
		beforeEach(async () => {
			// Re-import to reset state
			const rateLimitModule = await import("./rateLimit.js");
			vi.clearAllMocks();
		});

		it("should allow requests within rate limit", () => {
			expect(allowRequest("user1")).toBe(true);
			expect(allowRequest("user1")).toBe(true);
		});

		it("should allow requests for different users independently", () => {
			expect(allowRequest("user1")).toBe(true);
			expect(allowRequest("user2")).toBe(true);
		});

		it("should handle anonymous users", () => {
			expect(allowRequest("anon")).toBe(true);
			expect(allowRequest("anon")).toBe(true);
		});
	});

	describe("rateLimitLogin", () => {
		beforeEach(async () => {
			// Re-import to reset state
			vi.resetModules();
		});

		it("should allow login attempts within limit", () => {
			expect(rateLimitLogin("testuser")).toBe(true);
			expect(rateLimitLogin("testuser")).toBe(true);
		});

		it("should handle different users independently", () => {
			expect(rateLimitLogin("user1")).toBe(true);
			expect(rateLimitLogin("user2")).toBe(true);
		});
	});

	describe("resetLoginAttempts", () => {
		it("should not throw for any user", () => {
			expect(() => resetLoginAttempts("nonexistent")).not.toThrow();
			expect(() => resetLoginAttempts("testuser")).not.toThrow();
		});
	});

	describe("startCleanupInterval", () => {
		beforeEach(() => {
			vi.useFakeTimers();
		});

		it("should start cleanup interval", () => {
			const clearIntervalSpy = vi.spyOn(global, "clearInterval");
			const interval = startCleanupInterval();

			expect(interval).toBeDefined();

			// Advance time to trigger cleanup
			vi.advanceTimersByTime(300000);

			expect(logger.debug).toHaveBeenCalledWith("Periodic cleanup completed", {
				loginAttemptsSize: expect.any(Number),
				bucketsSize: expect.any(Number),
			});

			clearIntervalSpy.mockRestore();
		});

		it("should clear interval on SIGTERM", () => {
			const clearIntervalSpy = vi.spyOn(global, "clearInterval");
			const interval = startCleanupInterval();

			// Simulate SIGTERM
			process.emit("SIGTERM");

			expect(clearIntervalSpy).toHaveBeenCalledWith(interval);

			clearIntervalSpy.mockRestore();
		});
	});

	describe("createRateLimitMiddleware", () => {
		const mockNext = vi.fn().mockResolvedValue({ success: true });
		const mockContext = { userId: "user123" };

		beforeEach(() => {
			// Reset rate limit state
			vi.resetModules();
		});

		it("should allow requests within rate limit", async () => {
			const middleware = createRateLimitMiddleware();

			await middleware({
				ctx: mockContext,
				next: mockNext,
			});

			expect(mockNext).toHaveBeenCalled();
		});

		it("should handle anonymous users", async () => {
			const middleware = createRateLimitMiddleware();
			const anonymousContext = { userId: undefined };

			await middleware({
				ctx: anonymousContext,
				next: mockNext,
			});

			expect(mockNext).toHaveBeenCalled();
		});
	});

	describe("LOGIN_DELAY_MS", () => {
		it("should export correct delay value", () => {
			expect(LOGIN_DELAY_MS).toBe(300);
		});
	});
});
