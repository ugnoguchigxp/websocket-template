import { describe, it, expect, beforeAll, afterAll, beforeEach, vi } from 'vitest';
import WebSocket from 'ws';
import 'reflect-metadata';
import { container } from 'tsyringe';
import { ServerApp } from '../src/server.js';
import { prisma } from '../src/prisma.js';
import { mockEnv, createTestJWT } from './helpers/test-utils.js';
import argon2 from 'argon2';

describe('WebSocket Server Integration Tests', () => {
	let server: ServerApp;
	let port: number;
	let testUserId: number;
	let testToken: string;

	beforeAll(async () => {
		// 環境変数を設定
		mockEnv({
			...mockEnv(),
			ALLOWED_WS_ORIGIN: 'http://localhost:5173',
		});

		// テストユーザー作成
		const passwordHash = await argon2.hash('testpass', {
			type: argon2.argon2id,
			memoryCost: 2 ** 10,
			timeCost: 2,
			parallelism: 1,
		});

		const user = await prisma.user.create({
			data: {
				username: `wstest_${Date.now()}`,
				passwordHash,
			},
		});

		testUserId = user.id;
		testToken = createTestJWT(String(testUserId));

		// サーバーを起動
		container.reset();
		container.register('Prisma', { useValue: prisma });
		container.register('JWT_SECRET', { useValue: process.env.JWT_SECRET! });

		server = container.resolve(ServerApp);
		// ランダムポートを使用（0を指定）
		port = 40000 + Math.floor(Math.random() * 10000);
		await server.start(port);

		// サーバーが起動するのを待つ
		await new Promise((resolve) => setTimeout(resolve, 500));
	});

	afterAll(async () => {
		// テストユーザー削除
		await prisma.user.delete({ where: { id: testUserId } }).catch(() => {});
		await prisma.$disconnect();
	});

	describe('Connection Tests', () => {
		it('should establish WebSocket connection with valid token', (done) => {
			const ws = new WebSocket(`ws://localhost:${port}`, ['bearer', testToken]);

			ws.on('open', () => {
				expect(ws.readyState).toBe(WebSocket.OPEN);
				ws.close();
				done();
			});

			ws.on('error', (error) => {
				done(error);
			});
		});

		it('should accept connection without token (anonymous)', (done) => {
			const ws = new WebSocket(`ws://localhost:${port}`);

			ws.on('open', () => {
				expect(ws.readyState).toBe(WebSocket.OPEN);
				ws.close();
				done();
			});

			ws.on('error', (error) => {
				done(error);
			});
		});

		it('should reject connection with wrong origin', (done) => {
			const ws = new WebSocket(`ws://localhost:${port}`, {
				headers: {
					Origin: 'http://evil.com',
				},
			});

			ws.on('close', (code, reason) => {
				expect(code).toBe(1008); // Policy Violation
				done();
			});

			ws.on('open', () => {
				done(new Error('Connection should have been rejected'));
			});
		});

		it('should accept connection with token via query parameter', (done) => {
			const ws = new WebSocket(`ws://localhost:${port}?token=${testToken}`);

			ws.on('open', () => {
				expect(ws.readyState).toBe(WebSocket.OPEN);
				ws.close();
				done();
			});

			ws.on('error', (error) => {
				done(error);
			});
		});
	});

	describe('Heartbeat Tests', () => {
		it('should respond to ping with pong', (done) => {
			const ws = new WebSocket(`ws://localhost:${port}`, ['bearer', testToken]);

			ws.on('open', () => {
				ws.ping();
			});

			ws.on('pong', () => {
				ws.close();
				done();
			});

			ws.on('error', (error) => {
				done(error);
			});
		});

		it('should handle multiple ping/pong', (done) => {
			const ws = new WebSocket(`ws://localhost:${port}`, ['bearer', testToken]);
			let pongCount = 0;

			ws.on('open', () => {
				ws.ping();
				setTimeout(() => ws.ping(), 100);
				setTimeout(() => ws.ping(), 200);
			});

			ws.on('pong', () => {
				pongCount++;
				if (pongCount === 3) {
					ws.close();
					done();
				}
			});

			ws.on('error', (error) => {
				done(error);
			});
		});
	});

	describe('Message Handling Tests', () => {
		it('should handle tRPC message', (done) => {
			const ws = new WebSocket(`ws://localhost:${port}`, ['bearer', testToken]);

			ws.on('open', () => {
				// tRPC auth.me クエリ
				const message = JSON.stringify({
					id: 1,
					jsonrpc: '2.0',
					method: 'query',
					params: {
						path: 'auth.me',
						input: null,
					},
				});

				ws.send(message);
			});

			ws.on('message', (data) => {
				const response = JSON.parse(data.toString());
				expect(response.id).toBe(1);
				expect(response.result).toBeDefined();
				ws.close();
				done();
			});

			ws.on('error', (error) => {
				done(error);
			});
		});

		it('should reset idle timer on message', (done) => {
			const ws = new WebSocket(`ws://localhost:${port}`, ['bearer', testToken]);
			let messageCount = 0;

			ws.on('open', () => {
				// 複数のメッセージを送信してアイドルタイマーがリセットされることを確認
				const interval = setInterval(() => {
					if (messageCount < 5) {
						ws.send(JSON.stringify({ ping: messageCount }));
						messageCount++;
					} else {
						clearInterval(interval);
						ws.close();
						done();
					}
				}, 100);
			});

			ws.on('error', (error) => {
				done(error);
			});
		});
	});

	describe('Concurrent Connections Tests', () => {
		it('should handle multiple simultaneous connections', (done) => {
			const connectionCount = 10;
			const connections: WebSocket[] = [];
			let openCount = 0;

			for (let i = 0; i < connectionCount; i++) {
				const ws = new WebSocket(`ws://localhost:${port}`, ['bearer', testToken]);

				ws.on('open', () => {
					openCount++;
					if (openCount === connectionCount) {
						// 全ての接続が確立されたら閉じる
						connections.forEach((conn) => conn.close());
						done();
					}
				});

				ws.on('error', (error) => {
					done(error);
				});

				connections.push(ws);
			}
		});

		it('should handle connections and disconnections', (done) => {
			const ws1 = new WebSocket(`ws://localhost:${port}`, ['bearer', testToken]);
			const ws2 = new WebSocket(`ws://localhost:${port}`, ['bearer', testToken]);

			let ws1Open = false;
			let ws2Open = false;

			ws1.on('open', () => {
				ws1Open = true;
				checkBothOpen();
			});

			ws2.on('open', () => {
				ws2Open = true;
				checkBothOpen();
			});

			function checkBothOpen() {
				if (ws1Open && ws2Open) {
					// 両方開いたら、1つを閉じて、もう1つはまだ開いていることを確認
					ws1.close();

					setTimeout(() => {
						expect(ws2.readyState).toBe(WebSocket.OPEN);
						ws2.close();
						done();
					}, 100);
				}
			}

			ws1.on('error', (error) => {
				done(error);
			});

			ws2.on('error', (error) => {
				done(error);
			});
		});
	});

	describe('Error Handling Tests', () => {
		it('should handle invalid tRPC message', (done) => {
			const ws = new WebSocket(`ws://localhost:${port}`, ['bearer', testToken]);

			ws.on('open', () => {
				// 無効なJSON
				ws.send('invalid json');
			});

			ws.on('message', (data) => {
				const response = JSON.parse(data.toString());
				// tRPC should respond with an error
				expect(response.error).toBeDefined();
				ws.close();
				done();
			});

			ws.on('error', (error) => {
				// ネットワークエラーでなければテスト成功
				if (error.message.includes('invalid')) {
					ws.close();
					done();
				}
			});

			// タイムアウト設定
			setTimeout(() => {
				ws.close();
				done();
			}, 2000);
		});

		it('should handle connection close gracefully', (done) => {
			const ws = new WebSocket(`ws://localhost:${port}`, ['bearer', testToken]);

			ws.on('open', () => {
				ws.close();
			});

			ws.on('close', (code) => {
				expect(code).toBeGreaterThan(0);
				done();
			});

			ws.on('error', (error) => {
				done(error);
			});
		});
	});

	describe('Authentication Tests', () => {
		it('should authenticate with valid JWT in subprotocol', (done) => {
			const ws = new WebSocket(`ws://localhost:${port}`, ['bearer', testToken]);

			ws.on('open', () => {
				// auth.me クエリで認証状態を確認
				const message = JSON.stringify({
					id: 1,
					jsonrpc: '2.0',
					method: 'query',
					params: {
						path: 'auth.me',
						input: null,
					},
				});

				ws.send(message);
			});

			ws.on('message', (data) => {
				const response = JSON.parse(data.toString());
				expect(response.result).toBeDefined();
				expect(response.result.data).toBeDefined();
				expect(response.result.data.json).toBeDefined();
				ws.close();
				done();
			});

			ws.on('error', (error) => {
				done(error);
			});
		});

		it('should reject authenticated endpoint without token', (done) => {
			const ws = new WebSocket(`ws://localhost:${port}`);

			ws.on('open', () => {
				// auth.me クエリ（認証必須）
				const message = JSON.stringify({
					id: 1,
					jsonrpc: '2.0',
					method: 'query',
					params: {
						path: 'auth.me',
						input: null,
					},
				});

				ws.send(message);
			});

			ws.on('message', (data) => {
				const response = JSON.parse(data.toString());
				// UNAUTHORIZED エラーを期待
				expect(response.error).toBeDefined();
				expect(response.error.data).toBeDefined();
				ws.close();
				done();
			});

			ws.on('error', (error) => {
				done(error);
			});
		});
	});
});
